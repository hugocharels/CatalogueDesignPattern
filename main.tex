
\documentclass[french]{article}

% Encodage et langue
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}

% Mise en forme générale
\usepackage{fullpage}
\usepackage[parfill]{parskip}
\usepackage[hidelinks]{hyperref}  % Liens hypertext

% Graphiques et images
\usepackage{graphicx}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18,legend to name={customlegend}}
\usepgfplotslibrary{statistics}
\usetikzlibrary{pgfplots.statistics}
\usepackage{tikz}
\usepackage{svg}
\usepackage{subcaption}
\usepackage{rotating}
\usepackage{float} % Pour positionner les images

% Mathématiques
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{algorithm}
\usepackage{algpseudocode}

% Importation de code
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{xcolor}  % Couleur code

% Autres utilitaires
\usepackage{caption}
\usepackage{enumitem}
\usepackage{pifont}
\usepackage{multirow}
\usepackage{adjustbox}
\usepackage{lipsum} % Pour du texte factice
\usepackage{pdflscape}
\usepackage{adjustbox}
\usepackage{hyperref}
\usepackage[most]{tcolorbox}

% Définir le style par défaut
\tcbset{
  defaultstyle/.style={
    colback=gray!5!white,
    fonttitle=\bfseries
    
  }
}

% Pour le code
\lstset{
    language=Java,
    inputencoding=utf8/latin1,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green!70!black},
    stringstyle=\color{red},
    breaklines=true,
    showstringspaces=false,
    tabsize=4,
    frame=tb,
    numbers=left,
    numberstyle=\tiny\color{gray},
    captionpos=b
}

% Pour l'indentation
\usepackage{indentfirst} 
\setlength{\parindent}{1em} 

\usepackage{titlesec}
\titleformat{\section}[block]{\normalfont\Large\bfseries}{}{0em}{}


% Change font
%\usepackage[T1]{fontenc}
%\renewcommand*\rmdefault{}


\begin{document}

\begin{titlepage}
	\centering
    % \includegraphics[width=1\textwidth]{log.jpg}
    \vspace{2.5cm} 
    
    \noindent\rule{15cm}{0.4pt}
    \vspace{0.25cm} 
    {\huge\bfseries Catalogue de Design Pattern \par}
    \vspace{0.5cm}
    {\scshape\Large  \par}
    \vspace{0.5cm}
    \noindent\rule{15cm}{0.4pt}
    \vfill


% Bottom of the page
	{\Large\scshape Charels Hugo \par}
	\vspace{0.5cm}
	{\Large\scshape B-INFO\par}
	\vspace{1cm}
	{\large 2023-2024 \par}
\end{titlepage}


\tableofcontents
\clearpage

\newpage

\section{Patterns de Création (Creational)}


\subsection{Abstract Factory}

\subsubsection{Description}

Le design pattern Abstract Factory est un modèle de conception qui appartient à la catégorie des patrons de conception creational (de création). Son objectif principal est de fournir une interface pour créer des familles d'objets liés ou dépendants sans spécifier leurs classes concrètes. Cela signifie que le code client peut créer des objets sans avoir à connaître les détails spécifiques de leur implémentation.

Voici les principaux éléments qui composent le design pattern Abstract Factory :

\begin{enumerate}
    \item \textbf{Abstract Factory (Fabrique Abstraite)} :
    \begin{itemize}
        \item Il s'agit de l'interface définissant des méthodes pour créer chacun des types d'objets abstraits faisant partie de la famille d'objets.
        \item Chaque méthode de l'interface correspond à la création d'un type d'objet abstrait.
    \end{itemize}
    
    \item \textbf{Concrete Factory (Fabrique Concrète)} :
    \begin{itemize}
        \item Les implémentations concrètes de l'interface Abstract Factory.
        \item Chaque Concrete Factory est responsable de la création de toute une famille d'objets concrets.
    \end{itemize}
    
    \item \textbf{Abstract Product (Produit Abstrait)} :
    \begin{itemize}
        \item Interface ou classe abstraite définissant le comportement des objets de la famille.
        \item Chaque produit de la famille possède ses propres méthodes, mais ces méthodes sont déclarées dans l'interface ou la classe abstraite commune à tous les produits.
    \end{itemize}
    
    \item \textbf{Concrete Product (Produit Concret)} :
    \begin{itemize}
        \item Les implémentations concrètes des produits abstraits.
        \item Chaque Concrete Product est une implémentation spécifique d'un produit de la famille.
    \end{itemize}
    
    \item \textbf{Client} :
    \begin{itemize}
        \item Utilise l'interface de l'Abstract Factory pour créer des objets.
        \item N'a pas besoin de connaître les détails spécifiques de la création des objets.
        \item Travailler avec les objets via leurs interfaces abstraites.
    \end{itemize}
\end{enumerate}

Le processus de création d'objets avec le design pattern Abstract Factory se déroule comme suit :

\begin{enumerate}
    \item Le client appelle les méthodes de création de l'Abstract Factory pour obtenir des objets.
    \item L'Abstract Factory, en fonction de son type concret, crée les instances concrètes des produits de la famille.
    \item Le client utilise les objets créés via les interfaces abstraites, ce qui lui permet de rester indépendant des classes concrètes spécifiques.
\end{enumerate}

L'avantage principal de ce modèle est qu'il favorise la séparation des préoccupations en permettant aux clients de créer des familles d'objets apparentés sans avoir à connaître les détails de leur implémentation. Cela rend le code plus modulaire, plus flexible et plus facile à étendre. De plus, il favorise le principe de substitution de Liskov, car les objets peuvent être utilisés via leurs interfaces abstraites, permettant ainsi aux implémentations concrètes d'être interchangées facilement.

\subsubsection{Exemple}

Imaginons que nous construisons une application de rendu graphique qui doit fonctionner sur différentes plateformes, telles que Windows et Linux. Pour chaque plateforme, nous devons créer des boutons, des cases à cocher et des champs de texte avec un aspect spécifique à cette plateforme. Nous pouvons utiliser le Design Pattern Abstract Factory pour créer une fabrique abstraite qui sera implémentée par des fabriques concrètes pour chaque plateforme. Ainsi, notre code client peut créer des widgets sans se soucier de la plateforme sous-jacente.

\lstinputlisting[language=Java, caption=abstract\_factory.java]{src/creational/abstract_factory.java}



\newpage

\subsection{Builder}

\subsubsection{Description}

Le design pattern Builder est un modèle de conception appartenant à la catégorie des patrons de conception creational (de création). Son objectif principal est de séparer la construction d'un objet complexe de sa représentation, de sorte que le même processus de construction puisse créer différentes représentations.

Voici les principaux éléments qui composent le design pattern Builder :

\begin{enumerate}
    \item \textbf{Builder (Constructeur)} :
    \begin{itemize}
        \item Interface définissant les étapes de construction pour créer un objet complexe.
    \end{itemize}
    
    \item \textbf{Concrete Builder (Constructeur Concret)} :
    \begin{itemize}
        \item Implémente l'interface Builder pour fournir des étapes de construction concrètes pour un type spécifique d'objet complexe.
        \item Construit et assemble les parties de l'objet complexe selon les étapes spécifiées.
    \end{itemize}
    
    \item \textbf{Director (Directeur)} :
    \begin{itemize}
        \item Dirige le processus de construction en utilisant un Builder pour construire un objet complexe.
        \item Ne connaît pas les détails de la construction, mais utilise l'interface Builder pour orchestrer le processus.
    \end{itemize}
    
    \item \textbf{Product (Produit)} :
    \begin{itemize}
        \item Représente l'objet complexe en cours de construction.
        \item Peut être de n'importe quel type ou structure, en fonction de la logique de construction.
    \end{itemize}
\end{enumerate}

Le processus de construction d'un objet complexe avec le design pattern Builder se déroule comme suit :

\begin{enumerate}
    \item Le client crée un Builder concret et le passe au Directeur.
    \item Le Directeur utilise le Builder pour construire l'objet complexe en suivant les étapes définies.
    \item Une fois la construction terminée, le client récupère le produit du Builder.
\end{enumerate}

L'avantage principal de ce modèle est sa flexibilité et sa capacité à créer différentes représentations d'un même objet complexe. Il permet également de simplifier le code client en séparant la logique de construction de la logique métier. Cela facilite également l'ajout de nouvelles étapes de construction ou la modification de la logique de construction sans affecter le client.


\subsubsection{Exemple}

Supposons que nous construisons une application pour assembler des ordinateurs. Les ordinateurs peuvent avoir différentes configurations avec des composants variés, tels que le processeur, la carte graphique, la mémoire, etc. Nous pouvons utiliser le Design Pattern Builder pour définir une interface de construction abstraite et créer des constructeurs concrets pour chaque type d'ordinateur (gamer, bureautique, etc.). Ainsi, nous pouvons construire différents types d'ordinateurs en utilisant le même processus de construction.

\lstinputlisting[language=Java, caption=builder.java]{src/creational/builder.java}


\newpage

\subsection{Factory Method}

\subsubsection{Description}

Le design pattern Factory Method est un modèle de conception appartenant à la catégorie des patrons de conception creational (de création). Son objectif principal est de fournir une interface pour la création d'objets dans une classe, mais de permettre aux sous-classes de modifier le type d'objets qui seront instanciés.

Voici les principaux éléments qui composent le design pattern Factory Method :

\begin{enumerate}
    \item \textbf{Product (Produit)} :
    \begin{itemize}
        \item Interface ou classe abstraite définissant le type d'objets produits par le Factory Method.
    \end{itemize}
    
    \item \textbf{Concrete Product (Produit Concret)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface Product.
        \item Chaque Concrete Product représente un type spécifique d'objet créé par le Factory Method.
    \end{itemize}
    
    \item \textbf{Creator (Créateur)} :
    \begin{itemize}
        \item Classe abstraite qui définit la méthode factoryMethod().
        \item Cette méthode est responsable de la création d'objets de type Product.
    \end{itemize}
    
    \item \textbf{Concrete Creator (Créateur Concret)} :
    \begin{itemize}
        \item Implémentation concrète de la classe Creator.
        \item Override la méthode factoryMethod() pour créer des instances spécifiques de Concrete Product.
    \end{itemize}
\end{enumerate}

Le processus de création d'objets avec le design pattern Factory Method se déroule comme suit :

\begin{enumerate}
    \item Le client appelle la méthode factoryMethod() de la classe Creator pour obtenir une instance de Product.
    \item La classe Creator, qui peut être une classe abstraite ou une classe concrète, crée et retourne une instance de Concrete Product en appelant la méthode factoryMethod().
    \item Le client utilise ensuite l'objet Product obtenu via l'interface commune, sans avoir besoin de connaître la classe concrète réelle de l'objet.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet de déléguer la responsabilité de la création d'objets à des sous-classes, ce qui permet une meilleure extensibilité et une réduction du couplage entre les classes. Il facilite également l'ajout de nouveaux types d'objets sans avoir à modifier le code existant.


\subsubsection{Exemple}

Supposons que nous développons un logiciel de traitement d'images avec différents types de filtres (filtre noir et blanc, filtre sepia, etc.). Nous pouvons utiliser le Design Pattern Factory Method en définissant une classe abstraite "Filter" avec une méthode abstraite "apply", qui sera implémentée par les sous-classes pour créer des filtres spécifiques.

\lstinputlisting[language=Java, caption=factory\_method.java]{src/creational/factory_method.java}


\newpage

\subsection{Prototype}

\subsubsection{Description}

Le design pattern Prototype est un modèle de conception appartenant à la catégorie des patrons de conception creational (de création). Son objectif principal est de permettre la création d'objets en clonant une instance existante plutôt qu'en les instanciant à partir de zéro.

Voici les principaux éléments qui composent le design pattern Prototype :

\begin{enumerate}
    \item \textbf{Prototype} :
    \begin{itemize}
        \item Interface ou classe abstraite définissant la méthode clone().
        \item Cette méthode est utilisée pour créer une copie profonde ou superficielle de l'objet, selon les besoins.
    \end{itemize}
    
    \item \textbf{Concrete Prototype (Prototype Concret)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface Prototype.
        \item Définit la logique de clonage de l'objet.
    \end{itemize}
    
    \item \textbf{Client} :
    \begin{itemize}
        \item Utilise le Prototype pour créer de nouveaux objets en les clonant.
        \item Ne nécessite pas de connaître les détails de l'implémentation du clonage.
    \end{itemize}
\end{enumerate}

Le processus de création d'objets avec le design pattern Prototype se déroule comme suit :

\begin{enumerate}
    \item Le client demande la création d'un nouvel objet en utilisant un objet Prototype existant.
    \item Le Prototype, qui peut être une classe abstraite ou une classe concrète, utilise sa méthode clone() pour créer une copie de lui-même.
    \item Le client utilise ensuite l'objet cloné selon ses besoins.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet de créer de nouveaux objets avec un minimum d'effort, en évitant le processus de création coûteux. Il permet également de réduire la duplication de code et d'offrir une meilleure flexibilité en permettant la création de nouveaux types d'objets en utilisant des prototypes existants.

\subsubsection{Exemple}

Supposons que nous développons une application de dessin où les utilisateurs peuvent créer des formes géométriques. Pour créer une nouvelle forme, nous pouvons utiliser le Design Pattern Prototype en définissant une interface "Shape" avec une méthode "clone" qui sera implémentée par les sous-classes pour copier l'objet existant.

\lstinputlisting[language=Java, caption=prototype.java]{src/creational/prototype.java}


\newpage

\subsection{Singleton}

\subsubsection{Description}

Le design pattern Singleton est un modèle de conception appartenant à la catégorie des patrons de conception creational (de création). Son objectif principal est de garantir qu'une classe n'a qu'une seule instance et de fournir un point d'accès global à cette instance.

Voici les principaux éléments qui composent le design pattern Singleton :

\begin{enumerate}
    \item \textbf{Singleton} :
    \begin{itemize}
        \item Classe avec une méthode statique qui retourne toujours la même instance de cette classe.
        \item Le constructeur de la classe est généralement rendu privé pour empêcher l'instanciation directe de la classe en dehors de la classe elle-même.
    \end{itemize}
\end{enumerate}

Le processus d'utilisation du design pattern Singleton est assez simple :

\begin{enumerate}
    \item Les clients accèdent à l'instance unique de la classe Singleton en appelant la méthode statique de la classe.
    \item Si l'instance n'existe pas encore, elle est créée et stockée dans un champ statique privé de la classe.
    \item L'instance unique est ensuite retournée à chaque appel de la méthode statique.
\end{enumerate}

L'avantage principal de ce modèle est qu'il garantit qu'une classe n'a qu'une seule instance dans l'ensemble du programme, ce qui peut être utile pour des ressources partagées telles que des bases de données ou des fichiers de configuration. Cela évite également le gaspillage de ressources en évitant la création répétée d'instances et offre un point d'accès global pour accéder à cette instance unique.

Cependant, l'utilisation abusive du Singleton peut conduire à des problèmes de test unitaire et à des dépendances cachées, il convient donc de l'utiliser avec discernement.


\subsubsection{Exemple}

Supposons que nous développons une application qui a besoin d'une classe "Configuration" pour stocker les paramètres de configuration de l'application. Nous pouvons utiliser le Design Pattern Singleton pour s'assurer qu'il n'y a qu'une seule instance de la classe "Configuration" qui est partagée par l'ensemble de l'application.

\lstinputlisting[language=Java, caption=singleton.java]{src/creational/singleton.java}

\newpage

% --------------------------------------------------------------------------------



\section{Patterns de Structures (Structural)}

\subsection{Adapter}


\subsubsection{Description}

Le design pattern Adapter est un modèle de conception appartenant à la catégorie des patrons de conception structurels. Son objectif principal est de permettre à des interfaces incompatibles de travailler ensemble en convertissant l'interface d'une classe en une autre interface attendue par le client.

Voici les principaux éléments qui composent le design pattern Adapter :

\begin{enumerate}
    \item \textbf{Target (Cible)} :
    \begin{itemize}
        \item Interface que le client utilise pour interagir avec le système.
    \end{itemize}
    
    \item \textbf{Adapter (Adaptateur)} :
    \begin{itemize}
        \item Classe qui adapte l'interface d'une classe existante (Adaptee) à l'interface Target attendue par le client.
        \item Implémente l'interface Target et contient une instance de la classe Adaptee.
    \end{itemize}
    
    \item \textbf{Adaptee (Adapté)} :
    \begin{itemize}
        \item Classe existante dont l'interface n'est pas compatible avec l'interface Target.
        \item La classe que l'Adapter va adapter pour qu'elle puisse être utilisée par le client.
    \end{itemize}
\end{enumerate}

Le processus d'utilisation du design pattern Adapter se déroule comme suit :

\begin{enumerate}
    \item Le client utilise l'interface Target pour interagir avec le système.
    \item L'Adapter reçoit les appels de l'interface Target et les convertit en appels appropriés à l'interface de l'Adaptee.
    \item L'Adaptee exécute les opérations demandées et retourne les résultats à l'Adapter.
    \item L'Adapter convertit ensuite les résultats de l'Adaptee en un format compatible avec l'interface Target et les renvoie au client.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet d'intégrer des classes existantes dans de nouveaux systèmes sans avoir à modifier leur code source. Cela favorise la réutilisabilité du code et permet d'ajouter de nouvelles fonctionnalités sans affecter les composants existants. Cependant, l'utilisation abusive de ce modèle peut entraîner une complexité accrue du code en raison de l'ajout de plusieurs couches d'adaptation.


\subsubsection{Exemple}

Supposons que nous avons une classe "LegacyPrinter" qui utilise une ancienne interface pour l'impression de documents. Nous développons une nouvelle classe "ModernPrinter" qui utilise une interface différente pour l'impression. Pour que notre code client puisse utiliser les deux types d'imprimantes de manière interchangeable, nous pouvons utiliser le Design Pattern Adapter pour créer un adaptateur qui convertit l'interface de "ModernPrinter" en celle de "LegacyPrinter".

\lstinputlisting[language=Java, caption=adapter.java]{src/structural/adapter.java}


\newpage

\subsection{Bridge}

\subsubsection{Description}

Le design pattern Bridge est un modèle de conception appartenant à la catégorie des patrons de conception structurels. Son objectif principal est de séparer l'abstraction d'une classe de son implémentation, permettant ainsi à ces deux parties de varier indépendamment.

Voici les principaux éléments qui composent le design pattern Bridge :

\begin{enumerate}
    \item \textbf{Abstraction} :
    \begin{itemize}
        \item Interface qui définit les méthodes abstraites utilisées par le client.
        \item Contient une référence à un objet Implementor.
    \end{itemize}
    
    \item \textbf{Refined Abstraction (Abstraction Affinée)} :
    \begin{itemize}
        \item Implémentation spécifique de l'interface Abstraction.
        \item Peut ajouter des fonctionnalités supplémentaires.
    \end{itemize}
    
    \item \textbf{Implementor (Implémenteur)} :
    \begin{itemize}
        \item Interface qui définit les méthodes abstraites utilisées par Abstraction.
    \end{itemize}
    
    \item \textbf{Concrete Implementor (Implémenteur Concret)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface Implementor.
        \item Contient la logique détaillée de l'implémentation.
    \end{itemize}
\end{enumerate}

Le processus d'utilisation du design pattern Bridge se déroule comme suit :

\begin{enumerate}
    \item Le client utilise l'interface Abstraction pour interagir avec le système.
    \item L'Abstraction délègue une partie de son implémentation à l'objet Implementor référencé.
    \item Les différentes implémentations de Implementor peuvent être échangées dynamiquement sans affecter Abstraction.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet de séparer complètement l'abstraction de son implémentation, ce qui facilite l'évolution et la maintenance du code. Il permet également de réduire le couplage entre les classes en les reliant par des interfaces plutôt que par des implémentations concrètes. Cependant, cela peut introduire une complexité supplémentaire dans le code en raison de l'ajout de plusieurs couches d'abstraction et d'implémentation.


\subsubsection{Exemple}

Supposons que nous développons un système de formes géométriques avec différents types de dessin (par exemple, dessin vectoriel et dessin en raster). Au lieu de créer une classe pour chaque combinaison de forme et de dessin, nous pouvons utiliser le Design Pattern Bridge pour diviser la hiérarchie en deux parties : l'abstraction (Forme) et l'implémentation (Dessin). Ainsi, nous pouvons créer des ponts (bridges) entre les formes et les dessins pour obtenir différentes combinaisons de formes et de dessins.

\lstinputlisting[language=Java, caption=bridge.java]{src/structural/bridge.java}


\newpage

\subsection{Composite}

\subsubsection{Description}


Le design pattern Composite est un modèle de conception appartenant à la catégorie des patrons de conception structurels. Son objectif principal est de permettre la composition d'objets en structures arborescentes pour représenter les hiérarchies partie-tout.

Voici les principaux éléments qui composent le design pattern Composite :

\begin{enumerate}
    \item \textbf{Component (Composant)} :
    \begin{itemize}
        \item Interface ou classe abstraite commune à tous les composants de la structure.
        \item Définit les méthodes communes pour manipuler les composants.
    \end{itemize}
    
    \item \textbf{Leaf (Feuille)} :
    \begin{itemize}
        \item Implémentation concrète de la classe Component.
        \item Représente les éléments individuels de la structure qui n'ont pas de sous-composants.
    \end{itemize}
    
    \item \textbf{Composite} :
    \begin{itemize}
        \item Implémentation concrète de la classe Component.
        \item Représente les éléments de la structure qui ont des sous-composants.
        \item Contient une liste de références vers ses sous-composants.
    \end{itemize}
\end{enumerate}

Le processus d'utilisation du design pattern Composite se déroule comme suit :

\begin{enumerate}
    \item Les clients manipulent les composants de la structure via l'interface commune Component.
    \item Les opérations sont propagées récursivement dans la structure, avec chaque composant (feuille ou composite) déléguant les appels à ses sous-composants le cas échéant.
    \item Cela permet de traiter uniformément les composants individuels et les structures complexes de manière transparente.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet de manipuler des structures arborescentes de manière uniforme, en traitant les composants individuels et les structures composites de la même manière. Cela simplifie le code client en permettant de traiter une structure complexe comme une unité unique, tout en offrant une grande flexibilité dans la manipulation des composants. Cependant, cela peut rendre certaines opérations plus complexes en raison de la nécessité de gérer la récursion.


\subsubsection{Exemple}

Supposons que nous développons une application de modélisation de formes graphiques. Nous avons des formes simples (cercle, carré) et des groupes de formes qui peuvent contenir d'autres formes, y compris d'autres groupes. Avec le Design Pattern Composite, nous pouvons traiter les formes individuelles et les groupes de formes de manière homogène, ce qui facilite les opérations de dessin, de déplacement, etc.

\lstinputlisting[language=Java, caption=composite.java]{src/structural/composite.java}


\newpage

\subsection{Decorator}

\subsubsection{Description}

Le design pattern Decorator est un modèle de conception appartenant à la catégorie des patrons de conception structurels. Son objectif principal est d'ajouter dynamiquement de nouvelles fonctionnalités à un objet en les enveloppant dans des objets décorateurs plutôt que de les étendre par héritage.

Voici les principaux éléments qui composent le design pattern Decorator :

\begin{enumerate}
    \item \textbf{Component (Composant)} :
    \begin{itemize}
        \item Interface ou classe abstraite commune à tous les composants à décorer.
        \item Définit les méthodes de base que les décorateurs et les composants concrets implémentent.
    \end{itemize}
    
    \item \textbf{Concrete Component (Composant Concret)} :
    \begin{itemize}
        \item Implémentation concrète de la classe Component.
        \item Représente l'objet de base auquel des fonctionnalités supplémentaires peuvent être ajoutées.
    \end{itemize}
    
    \item \textbf{Decorator (Décorateur)} :
    \begin{itemize}
        \item Classe abstraite qui étend Component et enveloppe les composants concrets.
        \item Contient une référence à un objet de type Component.
    \end{itemize}
    
    \item \textbf{Concrete Decorator (Décorateur Concret)} :
    \begin{itemize}
        \item Implémentation concrète de la classe Decorator.
        \item Ajoute des fonctionnalités supplémentaires à l'objet de base en le décorant.
    \end{itemize}
\end{enumerate}

Le processus d'utilisation du design pattern Decorator se déroule comme suit :

\begin{enumerate}
    \item Les clients manipulent les composants à travers l'interface Component.
    \item Les fonctionnalités supplémentaires sont ajoutées dynamiquement en enveloppant le composant de base dans des décorateurs appropriés.
    \item Les décorateurs peuvent être empilés pour ajouter plusieurs fonctionnalités en cascade.
    \item Chaque décorateur transmet les appels aux méthodes de base du composant au composant sous-jacent, permettant ainsi une chaîne de responsabilité.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet d'ajouter des fonctionnalités supplémentaires à un objet de manière flexible et dynamique, sans avoir à modifier sa structure de classe. Cela favorise la réutilisabilité du code en permettant la combinaison libre de fonctionnalités à la volée. Cependant, cela peut rendre la lecture du code plus complexe en raison de la présence de plusieurs couches de décorateurs.


\subsubsection{Exemple}

Supposons que nous développons une application de café et nous avons différentes boissons (expresso, café au lait) avec des options supplémentaires (lait, chocolat, sucre). Avec le Design Pattern Decorator, nous pouvons ajouter les options supplémentaires de manière dynamique à chaque boisson sans avoir besoin de créer de nombreuses classes pour chaque combinaison possible.

\lstinputlisting[language=Java, caption=decorator.java]{src/structural/decorator.java}


\newpage

\subsection{Facade}

\subsubsection{Description}

Le design pattern Facade est un modèle de conception appartenant à la catégorie des patrons de conception structurels. Son objectif principal est de fournir une interface unifiée à un ensemble d'interfaces d'un sous-système afin de simplifier son utilisation et de masquer sa complexité.

Voici les principaux éléments qui composent le design pattern Facade :

\begin{enumerate}
    \item \textbf{Facade (Facade)} :
    \begin{itemize}
        \item Classe qui fournit une interface unifiée à un ensemble d'interfaces plus complexes dans un sous-système.
        \item Cache les détails de l'implémentation et simplifie l'interaction avec le sous-système.
    \end{itemize}
    
    \item \textbf{Subsystem (Sous-système)} :
    \begin{itemize}
        \item Ensemble de classes et d'interfaces qui implémentent les fonctionnalités du système.
        \item Ces classes ne sont pas directement accessibles par les clients mais sont utilisées par la facade pour réaliser les fonctionnalités demandées.
    \end{itemize}
\end{enumerate}

Le processus d'utilisation du design pattern Facade se déroule comme suit :

\begin{enumerate}
    \item Les clients interagissent avec la Facade pour accéder aux fonctionnalités du sous-système.
    \item La Facade traduit ces demandes en appels appropriés aux classes et interfaces du sous-système.
    \item La Facade simplifie ainsi l'utilisation du sous-système en fournissant une interface plus conviviale et en masquant sa complexité interne.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet de simplifier l'utilisation d'un sous-système complexe en fournissant une interface unifiée et conviviale. Cela permet aux clients de ne pas avoir à connaître les détails de l'implémentation du sous-système, ce qui favorise la modularité et la maintenance du code. Cependant, cela peut également limiter la flexibilité en cachant les détails d'implémentation, et il est important de concevoir soigneusement les interfaces de la Facade pour répondre aux besoins des clients.


\subsubsection{Exemple}

Supposons que nous développons une application pour gérer une voiture avec plusieurs sous-systèmes tels que le moteur, les freins, l'électronique, etc. Au lieu d'interagir directement avec chaque sous-système, nous pouvons créer une Facade Car pour regrouper les fonctionnalités de chaque sous-système et fournir une interface unique pour interagir avec la voiture.

\lstinputlisting[language=Java, caption=facade.java]{src/structural/facade.java}


\newpage

\subsection{Flyweight}

\subsubsection{Description}

Le design pattern Flyweight est un modèle de conception appartenant à la catégorie des patrons de conception structurels. Son objectif principal est de minimiser l'utilisation de la mémoire ou du calcul en partageant autant que possible les données similaires entre plusieurs objets.

Voici les principaux éléments qui composent le design pattern Flyweight :

\begin{enumerate}
    \item \textbf{Flyweight (Poids Léger)} :
    \begin{itemize}
        \item Interface ou classe abstraite commune à tous les objets légers.
        \item Contient les méthodes partagées entre les objets légers.
    \end{itemize}
    
    \item \textbf{ConcreteFlyweight (Poids Léger Concret)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface Flyweight.
        \item Représente un objet léger partagé qui stocke l'état intrinsèque (partagé) et ne dépend pas du contexte externe.
    \end{itemize}
    
    \item \textbf{UnsharedConcreteFlyweight (Poids Léger Non Partagé)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface Flyweight.
        \item Représente un objet léger qui ne peut pas être partagé et stocke l'état extrinsèque (non partagé).
    \end{itemize}
    
    \item \textbf{FlyweightFactory (Fabrique de Poids Légers)} :
    \begin{itemize}
        \item Gère et fournit les objets légers existants.
        \item Assure le partage des objets légers lors de leur création.
    \end{itemize}
\end{enumerate}

Le processus d'utilisation du design pattern Flyweight se déroule comme suit :

\begin{enumerate}
    \item Les clients demandent des objets légers à la FlyweightFactory.
    \item Si l'objet léger existe déjà dans la FlyweightFactory, il est renvoyé au client.
    \item Sinon, un nouvel objet léger est créé et stocké dans la FlyweightFactory pour une utilisation ultérieure.
    \item Les clients manipulent les objets légers via l'interface Flyweight.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet de réduire la consommation de mémoire en partageant les objets similaires entre plusieurs instances. Cela peut être particulièrement utile lorsque de nombreux objets doivent être créés, mais leur état est souvent répétitif. Cependant, cela peut également rendre le code plus complexe en raison de la nécessité de gérer les états partagés et non partagés.


\subsubsection{Exemple}

Supposons que nous développons un éditeur de texte où chaque caractère est représenté par un objet Character. Plutôt que de créer un nouvel objet Character pour chaque caractère du texte, nous pouvons utiliser le Design Pattern Flyweight pour stocker les caractères déjà créés dans un cache et les réutiliser lorsque le même caractère est demandé à nouveau.

\lstinputlisting[language=Java, caption=flyweight.java]{src/structural/flyweight.java}


\newpage

\subsection{Proxy}

\subsubsection{Description}

Le design pattern Proxy est un modèle de conception appartenant à la catégorie des patrons de conception structurels. Son objectif principal est de fournir un substitut ou un espace réservé à un autre objet afin de contrôler l'accès à celui-ci ou de fournir des fonctionnalités supplémentaires.

Voici les principaux éléments qui composent le design pattern Proxy :

\begin{enumerate}
    \item \textbf{Subject (Sujet)} :
    \begin{itemize}
        \item Interface ou classe abstraite commune à l'objet réel et à son proxy.
        \item Définit les méthodes communes que le proxy et l'objet réel implémentent.
    \end{itemize}
    
    \item \textbf{RealSubject (Sujet Réel)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface Subject.
        \item Représente l'objet réel dont l'accès est contrôlé par le proxy.
    \end{itemize}
    
    \item \textbf{Proxy} :
    \begin{itemize}
        \item Implémentation concrète de l'interface Subject.
        \item Contrôle l'accès à l'objet réel et fournit des fonctionnalités supplémentaires si nécessaire.
        \item Peut retarder la création et l'initialisation de l'objet réel jusqu'à ce qu'il soit vraiment nécessaire (lazy initialization).
    \end{itemize}
\end{enumerate}

Le processus d'utilisation du design pattern Proxy se déroule comme suit :

\begin{enumerate}
    \item Les clients interagissent avec le proxy à travers l'interface Subject.
    \item Si l'objet réel n'est pas encore créé, le proxy peut le créer et l'initialiser de manière transparente.
    \item Le proxy transmet ensuite les appels à l'objet réel ou effectue des traitements supplémentaires avant ou après la transmission de l'appel.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet de contrôler l'accès à l'objet réel et de fournir des fonctionnalités supplémentaires sans modifier son code. Cela peut être utile pour ajouter des fonctionnalités telles que la mise en cache, la journalisation, la sécurité ou la gestion des ressources. Cependant, cela peut également introduire une complexité supplémentaire dans le code en raison de la présence de plusieurs couches de proxy.


\subsubsection{Exemple}

Supposons que nous développons une application pour télécharger des fichiers depuis Internet. Le téléchargement des fichiers peut être coûteux en temps, nous pouvons donc utiliser un Proxy pour vérifier les autorisations de l'utilisateur avant de permettre le téléchargement et pour mettre en cache les fichiers téléchargés pour une utilisation ultérieure.

\lstinputlisting[language=Java, caption=proxy.java]{src/structural/proxy.java}


\newpage

\section{Patterns de Comportement (Behavioral)}

\subsection{Chain of Responsibility}

\subsubsection{Description}

Le design pattern Chain of Responsibility est un modèle de conception appartenant à la catégorie des patrons de conception comportementaux. Son objectif principal est de permettre le passage d'une requête le long d'une chaîne de traitements, où chaque maillon de la chaîne peut traiter la requête ou la transmettre au maillon suivant.

Voici les principaux éléments qui composent le design pattern Chain of Responsibility :

\begin{enumerate}
    \item \textbf{Handler (Gestionnaire)} :
    \begin{itemize}
        \item Interface ou classe abstraite commune à tous les gestionnaires.
        \item Définit une méthode pour traiter les requêtes et une référence au prochain gestionnaire dans la chaîne.
    \end{itemize}
    
    \item \textbf{ConcreteHandler (Gestionnaire Concret)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface Handler.
        \item Traite la requête si possible, sinon la transmet au prochain gestionnaire dans la chaîne.
    \end{itemize}
\end{enumerate}

Le processus d'utilisation du design pattern Chain of Responsibility se déroule comme suit :

\begin{enumerate}
    \item Les clients envoient des requêtes à un gestionnaire initial dans la chaîne.
    \item Chaque gestionnaire décide s'il peut traiter la requête ou s'il doit la transmettre au gestionnaire suivant.
    \item La requête est transmise le long de la chaîne jusqu'à ce qu'elle soit traitée ou que la fin de la chaîne soit atteinte.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet de découpler l'émetteur d'une requête de ses destinataires en permettant à plusieurs objets de tenter de traiter la requête sans connaître explicitement les autres. Cela favorise la flexibilité et la réutilisabilité du code en permettant de modifier dynamiquement la chaîne de responsabilité ou d'ajouter de nouveaux gestionnaires sans modifier le code client. Cependant, cela peut également rendre la gestion des requêtes plus complexe si la chaîne devient trop longue ou si les gestionnaires ne sont pas correctement configurés.


\subsubsection{Exemple}

Supposons que nous développons une application de gestion des demandes de congés dans une entreprise. Nous pouvons utiliser le Design Pattern Chain of Responsibility pour créer une chaîne de responsabilité où chaque gestionnaire (par exemple, RH, manager, directeur) peut approuver ou rejeter la demande de congé. Si un gestionnaire ne peut pas traiter la demande, il la transmet au gestionnaire supérieur dans la chaîne.

\lstinputlisting[language=Java, caption=chain\_of\_responsibility.java]{src/behavioral/chain_of_responsibility.java}


\newpage

\subsection{Command}

\subsubsection{Description}


Le design pattern Command est un modèle de conception appartenant à la catégorie des patrons de conception comportementaux. Son objectif principal est d'encapsuler une requête en tant qu'objet, ce qui permet de paramétrer des clients avec différentes requêtes, de mettre en file d'attente les requêtes, de les enregistrer et d'annuler les opérations.

Voici les principaux éléments qui composent le design pattern Command :

\begin{enumerate}
    \item \textbf{Command (Commande)} :
    \begin{itemize}
        \item Interface ou classe abstraite commune à tous les commandes.
        \item Définit une méthode pour exécuter la commande.
    \end{itemize}
    
    \item \textbf{ConcreteCommand (Commande Concrite)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface Command.
        \item Contient une référence à l'objet receveur (celui qui effectue l'action) et implémente la méthode pour exécuter la commande en appelant une ou plusieurs méthodes du receveur.
    \end{itemize}
    
    \item \textbf{Invoker (Invocateur)} :
    \begin{itemize}
        \item Demande à la commande d'exécuter une action.
        \item Ne connaît pas les détails de l'implémentation de la commande.
    \end{itemize}
    
    \item \textbf{Receiver (Receveur)} :
    \begin{itemize}
        \item Connaît la manière d'effectuer l'action associée à la commande.
        \item Implémente les méthodes que les commandes appellent pour effectuer les opérations.
    \end{itemize}
\end{enumerate}

Le processus d'utilisation du design pattern Command se déroule comme suit :

\begin{enumerate}
    \item Un objet de commande est créé et associé à un receveur.
    \item L'objet de commande est passé à l'invocateur.
    \item L'invocateur demande à l'objet de commande d'exécuter une action.
    \item L'objet de commande appelle la méthode appropriée sur le receveur pour effectuer l'action.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet de déconnecter l'objet qui invoque l'opération de celui qui la traite, ce qui permet de créer des systèmes flexibles et extensibles. Il permet également de mettre en file d'attente, d'enregistrer et d'annuler des opérations facilement. Cependant, cela peut rendre le code plus complexe en introduisant de nombreux objets de commande et en nécessitant une gestion appropriée de leur cycle de vie.


\subsubsection{Exemple}

Supposons que nous développons une application de traitement de texte où nous souhaitons permettre aux utilisateurs d'effectuer des opérations telles que copier, coller et annuler. Nous pouvons utiliser le Design Pattern Command pour créer des classes de commandes (par exemple, CopyCommand, PasteCommand, UndoCommand) qui encapsulent chaque opération et les exécuter au besoin.

\lstinputlisting[language=Java, caption=command.java]{src/behavioral/command.java}


\newpage

\subsection{Interpreter}

\subsubsection{Description}

Le design pattern Interpreter est un modèle de conception appartenant à la catégorie des patrons de conception comportementaux. Son objectif principal est de définir une grammaire pour un langage et de fournir un moyen d'interpréter et d'exécuter ce langage.

Voici les principaux éléments qui composent le design pattern Interpreter :

\begin{enumerate}
    \item \textbf{AbstractExpression (Expression Abstraite)} :
    \begin{itemize}
        \item Interface ou classe abstraite commune à toutes les expressions.
        \item Définit une méthode pour interpréter une expression donnée.
    \end{itemize}
    
    \item \textbf{TerminalExpression (Expression Terminale)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface AbstractExpression.
        \item Représente une expression de base qui ne peut pas être décomposée en d'autres expressions.
    \end{itemize}
    
    \item \textbf{NonterminalExpression (Expression Non Terminale)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface AbstractExpression.
        \item Représente une expression composée de sous-expressions.
    \end{itemize}
    
    \item \textbf{Context (Contexte)} :
    \begin{itemize}
        \item Contient des informations globales qui sont partagées entre les expressions pendant l'interprétation.
    \end{itemize}
    
    \item \textbf{Client} :
    \begin{itemize}
        \item Construit et configure l'arbre d'expression.
        \item Évalue les expressions en appelant la méthode d'interprétation sur la racine de l'arbre.
    \end{itemize}
\end{enumerate}

Le processus d'utilisation du design pattern Interpreter se déroule comme suit :

\begin{enumerate}
    \item Les clients construisent un arbre d'expression à partir d'expressions terminales et non terminales.
    \item Les clients évaluent l'expression en appelant la méthode d'interprétation sur la racine de l'arbre.
    \item Chaque nœud de l'arbre d'expression interprète et évalue les sous-expressions, transmettant le contexte si nécessaire.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet de définir une grammaire pour un langage et d'interpréter les expressions de manière flexible. Cela peut être utile pour implémenter des langages de programmation, des systèmes de requêtes ou d'autres systèmes basés sur la logique. Cependant, cela peut rendre le code complexe en raison de la nécessité de définir de nombreuses classes d'expressions et de gérer la construction de l'arbre d'expression.


\subsubsection{Exemple}

Supposons que nous développons une application pour évaluer des expressions arithmétiques simples, telles que "2 + 3 * 4". Nous pouvons utiliser le Design Pattern Interpreter pour créer une grammaire et un interpréteur qui évalue ces expressions.

\lstinputlisting[language=Java, caption=interpreter.java]{src/behavioral/interpreter.java}



\newpage


\subsection{Iterator}

\subsubsection{Description}

Le design pattern Iterator est un modèle de conception appartenant à la catégorie des patrons de conception comportementaux. Son objectif principal est de fournir un moyen d'accéder séquentiellement aux éléments d'une collection sans exposer sa représentation interne.

Voici les principaux éléments qui composent le design pattern Iterator :

\begin{enumerate}
    \item \textbf{Iterator (Itérateur)} :
    \begin{itemize}
        \item Interface ou classe abstraite commune à tous les itérateurs.
        \item Définit des méthodes pour parcourir la collection, obtenir l'élément suivant et vérifier s'il reste des éléments.
    \end{itemize}
    
    \item \textbf{ConcreteIterator (Itérateur Concret)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface Iterator.
        \item Maintient une référence à la position actuelle dans la collection et implémente les méthodes pour parcourir la collection.
    \end{itemize}
    
    \item \textbf{Aggregate (Agrégat)} :
    \begin{itemize}
        \item Interface ou classe abstraite commune à toutes les collections.
        \item Définit une méthode pour créer un itérateur.
    \end{itemize}
    
    \item \textbf{ConcreteAggregate (Agrégat Concret)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface Aggregate.
        \item Fournit une méthode pour créer un itérateur qui parcourt la collection spécifique.
    \end{itemize}
\end{enumerate}

Le processus d'utilisation du design pattern Iterator se déroule comme suit :

\begin{enumerate}
    \item Les clients obtiennent un itérateur à partir de la collection en appelant la méthode de création d'itérateur de l'agrégat.
    \item Les clients utilisent l'itérateur pour parcourir séquentiellement les éléments de la collection en utilisant les méthodes définies dans l'interface Iterator.
    \item L'itérateur maintient la position actuelle dans la collection et permet aux clients d'accéder à chaque élément individuellement sans avoir à connaître les détails de la collection sous-jacente.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet de parcourir les éléments d'une collection de manière flexible et indépendante de sa représentation interne. Cela favorise la réutilisabilité du code en permettant d'utiliser les mêmes itérateurs avec différentes collections, tout en préservant l'encapsulation des collections. Cependant, cela peut rendre le code plus complexe en raison de la nécessité de définir des classes d'itérateurs pour chaque type de collection.


\subsubsection{Exemple}

Supposons que nous développons une application pour gérer une liste de tâches. Nous pouvons utiliser le Design Pattern Iterator pour permettre aux clients de parcourir les tâches dans la liste sans avoir à connaître la structure sous-jacente de la liste.

\lstinputlisting[language=Java, caption=iterator.java]{src/behavioral/iterator.java}


\newpage

\subsection{Mediator}

\subsubsection{Description}

Le design pattern Mediator est un modèle de conception appartenant à la catégorie des patrons de conception comportementaux. Son objectif principal est de définir un objet qui encapsule la manière dont un ensemble d'objets interagissent, en favorisant la déconnexion entre ces objets.

Voici les principaux éléments qui composent le design pattern Mediator :

\begin{enumerate}
    \item \textbf{Mediator (Médiateur)} :
    \begin{itemize}
        \item Interface ou classe abstraite commune à tous les médiateurs.
        \item Définit des méthodes pour permettre la communication entre les objets du système.
    \end{itemize}
    
    \item \textbf{ConcreteMediator (Médiateur Concret)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface Mediator.
        \item Gère la communication entre les objets en implémentant les méthodes définies dans l'interface Mediator.
    \end{itemize}
    
    \item \textbf{Colleague (Collègue)} :
    \begin{itemize}
        \item Classe abstraite ou interface commune à tous les collègues.
        \item Définit des méthodes pour interagir avec d'autres collègues via le médiateur.
    \end{itemize}
    
    \item \textbf{ConcreteColleague (Collègue Concret)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface Colleague.
        \item Communique avec d'autres collègues via le médiateur, en utilisant les méthodes définies dans l'interface Colleague.
    \end{itemize}
\end{enumerate}

Le processus d'utilisation du design pattern Mediator se déroule comme suit :

\begin{enumerate}
    \item Les collègues communiquent entre eux en passant par le médiateur.
    \item Lorsqu'un collègue a besoin de communiquer avec un autre collègue, il appelle une méthode sur le médiateur.
    \item Le médiateur reçoit l'appel et transmet l'information au collègue concerné.
    \item Le médiateur peut effectuer des traitements supplémentaires avant de transmettre l'information au collègue destinataire.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet de déconnecter étroitement les objets du système en évitant les dépendances directes entre eux. Cela favorise la modularité et la maintenabilité du code en réduisant le couplage. Cependant, cela peut rendre le médiateur complexe s'il doit gérer de nombreuses interactions entre les collègues, et il est important de concevoir soigneusement les interfaces du médiateur et des collègues pour faciliter la communication.


\subsubsection{Exemple}

Supposons que nous développons un système de chat où plusieurs utilisateurs peuvent communiquer entre eux. Nous pouvons utiliser le Design Pattern Mediator pour créer un médiateur qui gère les communications entre les utilisateurs, de sorte qu'ils n'aient pas besoin de se connaître mutuellement.

\lstinputlisting[language=Java, caption=mediator.java]{src/behavioral/mediator.java}


\newpage

\subsection{Memento}

\subsubsection{Description}

Le design pattern Memento est un modèle de conception appartenant à la catégorie des patrons de conception comportementaux. Son objectif principal est de capturer et d'externaliser l'état interne d'un objet sans violer l'encapsulation, de manière à pouvoir le restaurer ultérieurement dans son état précédent.

Voici les principaux éléments qui composent le design pattern Memento :

\begin{enumerate}
    \item \textbf{Memento (Mémento)} :
    \begin{itemize}
        \item Interface ou classe abstraite commune à tous les mementos.
        \item Définit des méthodes pour accéder à l'état sauvegardé.
    \end{itemize}
    
    \item \textbf{ConcreteMemento (Mémento Concret)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface Memento.
        \item Stocke l'état interne de l'objet d'origine à un moment donné.
    \end{itemize}
    
    \item \textbf{Originator (Créateur)} :
    \begin{itemize}
        \item Classe dont l'état interne doit être sauvegardé.
        \item Crée un memento contenant une copie de son état interne et peut restaurer son état à partir d'un memento donné.
    \end{itemize}
    
    \item \textbf{Caretaker (Gardien)} :
    \begin{itemize}
        \item Classe responsable de la gestion des mementos.
        \item Stocke les mementos dans une liste ou une structure de données appropriée et les fournit à l'originateur pour la restauration.
    \end{itemize}
\end{enumerate}

Le processus d'utilisation du design pattern Memento se déroule comme suit :

\begin{enumerate}
    \item L'originateur crée un memento pour sauvegarder son état interne à un moment donné.
    \item L'originateur peut utiliser ce memento pour restaurer son état interne à un moment ultérieur.
    \item Le gardien peut stocker plusieurs mementos pour permettre la restauration de l'état à différents points dans le temps.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet de restaurer l'état d'un objet à un moment antérieur sans violer son encapsulation. Cela peut être utile pour implémenter des fonctionnalités telles que l'annulation et la restauration d'actions dans une application. Cependant, cela peut également augmenter la consommation de mémoire si de nombreux mementos doivent être stockés, et il est important de gérer correctement le cycle de vie des mementos pour éviter les fuites de mémoire.


\subsubsection{Exemple}

Supposons que nous développons un éditeur de texte où les utilisateurs peuvent écrire et modifier du texte. Nous pouvons utiliser le Design Pattern Memento pour créer des mementos qui sauvegardent l'état du texte à un moment donné, afin de pouvoir restaurer cet état ultérieurement.

\lstinputlisting[language=Java, caption=memento.java]{src/behavioral/memento.java}


\newpage

\subsection{Observer}

\subsubsection{Description}

Le design pattern Observer est un modèle de conception appartenant à la catégorie des patrons de conception comportementaux. Son objectif principal est de définir une dépendance de type un-à-plusieurs entre objets, de manière à ce que lorsqu'un objet change d'état, tous ses dépendants soient notifiés et mis à jour automatiquement.

Voici les principaux éléments qui composent le design pattern Observer :

\begin{enumerate}
    \item \textbf{Subject (Sujet)} :
    \begin{itemize}
        \item Interface ou classe abstraite commune à tous les sujets observables.
        \item Définit des méthodes pour ajouter, supprimer et notifier des observateurs.
    \end{itemize}
    
    \item \textbf{ConcreteSubject (Sujet Concret)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface Subject.
        \item Maintient l'état interne et notifie les observateurs lorsque cet état change.
    \end{itemize}
    
    \item \textbf{Observer (Observateur)} :
    \begin{itemize}
        \item Interface ou classe abstraite commune à tous les observateurs.
        \item Définit une méthode de mise à jour appelée par le sujet lorsqu'un changement d'état se produit.
    \end{itemize}
    
    \item \textbf{ConcreteObserver (Observateur Concret)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface Observer.
        \item Enregistre son intérêt pour les notifications auprès du sujet et réagit aux mises à jour de celui-ci.
    \end{itemize}
\end{enumerate}

Le processus d'utilisation du design pattern Observer se déroule comme suit :

\begin{enumerate}
    \item Les observateurs s'enregistrent auprès du sujet pour recevoir des notifications.
    \item Lorsque l'état du sujet change, il notifie tous ses observateurs en appelant leur méthode de mise à jour.
    \item Les observateurs réagissent aux notifications en mettant à jour leur état ou en effectuant d'autres actions en conséquence.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet de maintenir la cohérence entre les objets en évitant les dépendances directes et en favorisant la séparation des préoccupations. Cela favorise la modularité et la réutilisabilité du code en permettant de connecter et de déconnecter facilement les observateurs du sujet. Cependant, cela peut rendre le code plus complexe en raison de la multiplicité des interactions entre les sujets et les observateurs.


\subsubsection{Exemple}

Supposons que nous développons une application météo où les utilisateurs peuvent s'abonner pour recevoir des mises à jour en temps réel sur la météo. Nous pouvons utiliser le Design Pattern Observer pour créer des observateurs (abonnés) qui sont notifiés chaque fois que les données météorologiques changent.

\lstinputlisting[language=Java, caption=observer.java]{src/behavioral/observer.java}


\newpage

\subsection{State}

\subsubsection{Description}

Le design pattern State est un modèle de conception appartenant à la catégorie des patrons de conception comportementaux. Son objectif principal est de permettre à un objet de modifier son comportement lorsqu'il change son état interne, de manière à ce que sa classe apparaisse modifiée.

Voici les principaux éléments qui composent le design pattern State :

\begin{enumerate}
    \item \textbf{State (État)} :
    \begin{itemize}
        \item Interface ou classe abstraite commune à tous les états possibles de l'objet contexte.
        \item Définit les méthodes que l'objet contexte peut appeler pour modifier son comportement.
    \end{itemize}
    
    \item \textbf{ConcreteState (État Concret)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface State.
        \item Représente un état spécifique de l'objet contexte et implémente les méthodes définies dans l'interface State pour modifier son comportement en fonction de cet état.
    \end{itemize}
    
    \item \textbf{Context (Contexte)} :
    \begin{itemize}
        \item Classe qui possède un état interne.
        \item Utilise l'interface State pour déléguer les requêtes associées à un certain état à l'objet ConcreteState approprié.
    \end{itemize}
\end{enumerate}

Le processus d'utilisation du design pattern State se déroule comme suit :

\begin{enumerate}
    \item Le contexte délègue les requêtes associées à un certain état à l'objet ConcreteState approprié.
    \item L'objet ConcreteState modifie le comportement du contexte en réponse à la requête.
    \item Lorsque le contexte change d'état, il change également l'objet ConcreteState associé en conséquence.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet de définir un comportement spécifique pour chaque état d'un objet sans avoir recours à de longues séries d'instructions conditionnelles. Cela favorise la modularité et la maintenabilité du code en séparant les responsabilités liées à chaque état dans des classes distinctes. Cependant, cela peut augmenter la complexité du code en introduisant de nombreuses classes d'états et en nécessitant une gestion appropriée de la transition entre les états.


\subsubsection{Exemple}

Supposons que nous développons un lecteur de musique qui peut être dans trois états : Lecture, Pause et Arrêt. Nous pouvons utiliser le Design Pattern State pour modéliser ces états et gérer les transitions entre eux.

\lstinputlisting[language=Java, caption=state.java]{src/behavioral/state.java}



\newpage

\subsection{Strategy}

\subsubsection{Description}

Le design pattern Strategy est un modèle de conception appartenant à la catégorie des patrons de conception comportementaux. Son objectif principal est de définir une famille d'algorithmes, encapsuler chacun d'eux et les rendre interchangeables. Ainsi, un client peut choisir dynamiquement l'algorithme approprié sans modifier la classe cliente.

Voici les principaux éléments qui composent le design pattern Strategy :

\begin{enumerate}
    \item \textbf{Strategy (Stratégie)} :
    \begin{itemize}
        \item Interface ou classe abstraite commune à toutes les stratégies.
        \item Définit une méthode ou un ensemble de méthodes utilisées par le contexte pour exécuter l'algorithme.
    \end{itemize}
    
    \item \textbf{ConcreteStrategy (Stratégie Concrète)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface Strategy.
        \item Contient l'algorithme spécifique à exécuter.
    \end{itemize}
    
    \item \textbf{Context (Contexte)} :
    \begin{itemize}
        \item Classe qui utilise une stratégie pour exécuter un algorithme.
        \item Peut modifier la stratégie utilisée à tout moment pendant l'exécution.
    \end{itemize}
\end{enumerate}

Le processus d'utilisation du design pattern Strategy se déroule comme suit :

\begin{enumerate}
    \item Le contexte encapsule une référence à une stratégie.
    \item Lorsqu'une opération est requise, le contexte appelle la méthode de la stratégie pour exécuter l'algorithme.
    \item Le client peut modifier la stratégie du contexte à tout moment en remplaçant la stratégie par une autre stratégie compatible.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet de définir une famille d'algorithmes, encapsuler chacun d'eux et les rendre interchangeables. Cela favorise la flexibilité et la réutilisabilité du code en permettant de choisir dynamiquement l'algorithme approprié à exécuter. Cependant, cela peut augmenter la complexité du code en introduisant de nombreuses classes de stratégies et en nécessitant une gestion appropriée des contextes et des stratégies.


\subsubsection{Exemple}

Supposons que nous développons une application de paiement en ligne, où les utilisateurs peuvent choisir différents modes de paiement (carte de crédit, PayPal, virement bancaire). Nous pouvons utiliser le Design Pattern Strategy pour définir une stratégie pour chaque mode de paiement et permettre au client de choisir la stratégie souhaitée.

\lstinputlisting[language=Java, caption=strategy.java]{src/behavioral/strategy.java}


\newpage

\subsection{Template Method}

\subsubsection{Description}

Le design pattern Template Method est un modèle de conception appartenant à la catégorie des patrons de conception comportementaux. Son objectif principal est de définir le squelette d'un algorithme dans une opération, en laissant certains de ses pas aux sous-classes. Ainsi, les sous-classes peuvent redéfinir certaines étapes de l'algorithme sans en changer la structure globale.

Voici les principaux éléments qui composent le design pattern Template Method :

\begin{enumerate}
    \item \textbf{AbstractClass (Classe Abstraite)} :
    \begin{itemize}
        \item Classe qui définit le squelette de l'algorithme dans une méthode template.
        \item Contient des méthodes concrètes, abstraites ou facultatives, qui sont utilisées par la méthode template.
    \end{itemize}
    
    \item \textbf{ConcreteClass (Classe Concrète)} :
    \begin{itemize}
        \item Implémentation concrète de l'AbstractClass.
        \item Redéfinit les méthodes abstraites ou facultatives selon les besoins spécifiques de l'algorithme.
    \end{itemize}
\end{enumerate}

Le processus d'utilisation du design pattern Template Method se déroule comme suit :

\begin{enumerate}
    \item La classe abstraite définit une méthode template qui encapsule l'algorithme, en appelant séquentiellement les différentes étapes de l'algorithme.
    \item Les étapes de l'algorithme qui peuvent varier sont définies comme des méthodes abstraites ou facultatives dans la classe abstraite.
    \item Les classes concrètes étendent la classe abstraite et redéfinissent les méthodes abstraites ou facultatives selon les besoins spécifiques de l'algorithme.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet de définir une structure générale pour un algorithme tout en permettant aux sous-classes de redéfinir certaines étapes de cet algorithme sans en changer la structure globale. Cela favorise la réutilisabilité du code en évitant la duplication de code pour des algorithmes similaires. Cependant, cela peut également rendre le code plus complexe en introduisant des classes abstraites et en nécessitant une bonne compréhension de la structure générale de l'algorithme.


\subsubsection{Exemple}

Supposons que nous développons un jeu où les joueurs peuvent choisir différentes classes de personnages (guerrier, mage, archer). Chaque classe a une méthode de combat spécifique, mais le déroulement général du combat reste le même pour toutes les classes. Nous pouvons utiliser le Design Pattern Template Method pour définir un modèle de méthode de combat et laisser chaque classe de personnage implémenter ses propres attaques spécifiques.

\lstinputlisting[language=Java, caption=template\_method.java]{src/behavioral/template_method.java}



\newpage

\subsection{Visitor}

\subsubsection{Description}

Le design pattern Visitor est un modèle de conception appartenant à la catégorie des patrons de conception comportementaux. Son objectif principal est de permettre de définir de nouvelles opérations sur une structure d'objets sans modifier les classes de ces objets.

Voici les principaux éléments qui composent le design pattern Visitor :

\begin{enumerate}
    \item \textbf{Visitor (Visiteur)} :
    \begin{itemize}
        \item Interface ou classe abstraite commune à tous les visiteurs.
        \item Définit des méthodes pour visiter chaque type d'objet de la structure.
    \end{itemize}
    
    \item \textbf{ConcreteVisitor (Visiteur Concret)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface Visitor.
        \item Contient l'implémentation des méthodes de visite pour chaque type d'objet de la structure.
    \end{itemize}
    
    \item \textbf{Element (Élément)} :
    \begin{itemize}
        \item Interface ou classe abstraite commune à tous les éléments de la structure.
        \item Définit une méthode accept pour accepter les visites des visiteurs.
    \end{itemize}
    
    \item \textbf{ConcreteElement (Élément Concret)} :
    \begin{itemize}
        \item Implémentation concrète de l'interface Element.
        \item Implémente la méthode accept en appelant la méthode de visite correspondante sur le visiteur.
    \end{itemize}
    
    \item \textbf{ObjectStructure (Structure d'Objets)} :
    \begin{itemize}
        \item Collection d'objets à visiter.
        \item Fournit une méthode pour itérer sur les objets et appeler leur méthode accept pour accepter les visites des visiteurs.
    \end{itemize}
\end{enumerate}

Le processus d'utilisation du design pattern Visitor se déroule comme suit :

\begin{enumerate}
    \item Les visiteurs implémentent des méthodes de visite pour chaque type d'objet de la structure.
    \item Chaque objet de la structure implémente une méthode accept qui appelle la méthode de visite correspondante sur le visiteur.
    \item Lorsque la structure doit être parcourue, chaque objet accepte les visites des visiteurs appropriés.
\end{enumerate}

L'avantage principal de ce modèle est qu'il permet d'ajouter de nouvelles opérations sur une structure d'objets sans modifier les classes de ces objets. Cela favorise la modularité et la maintenabilité du code en séparant les opérations à appliquer sur les objets de la structure dans des classes de visiteurs distinctes. Cependant, cela peut augmenter la complexité du code en introduisant de nombreuses classes de visiteurs et en nécessitant une bonne compréhension de la structure d'objets et des opérations à appliquer.


\subsubsection{Exemple}

Supposons que nous développons une application de dessin avec différentes formes géométriques (cercle, carré, triangle). Nous voulons pouvoir ajouter de nouvelles fonctionnalités, telles que le calcul de l'aire ou le déplacement des formes, sans modifier les classes existantes. Nous pouvons utiliser le Design Pattern Visitor pour définir un visiteur externe pour chaque nouvelle fonctionnalité.

\lstinputlisting[language=Java, caption=visitor.java]{src/behavioral/visitor.java}


\end{document}
